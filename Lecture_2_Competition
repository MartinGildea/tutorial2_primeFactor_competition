# primeFactors.py

# import test code
from lab2Test import speedTestFun

# --------------------------------
# primeFactors()
# input:  a positive integer n (e.g. 19162234)
# output: a list of the prime factors of n with multiplicity (e.g. [2, 7, 7, 13, 13, 13, 89])
# --------------------------------
# Log to measure times and ensure I'm not taking a step backwards, will archive code in other files.
# First attempt: Finds all prime numbers then divides target number from bottom up t > 1 hour
# ---------------------------------------------------------------------------------------------
# Second attempt: Uses sieve to find prime numbers. Seems faster but still t > 1 hour.
# Actual factorising takes milliseconds after all prime numbers are found.
# ------------------------------------------------------------------------------------------------
# Third attempt: removed need to find all prime numbers t = 0.372s
#------------------------------------------------------------------------------------------------
# Fourth Attempt: Removed print commands that give me information and optimised code slightly
# t = 0.344s

def primeFactors(n):
    primeList = []
    possiblePrimeFactor = n
    factorPair = 2
    while n != 1:
        while factorPair * factorPair <= possiblePrimeFactor:
            if possiblePrimeFactor % factorPair:
                factorPair = factorPair + 1
            else:
                possiblePrimeFactor = possiblePrimeFactor / factorPair
        primeList.append(possiblePrimeFactor)
        n = n / possiblePrimeFactor
        possiblePrimeFactor = n
        factorPair = 2
    primeList.sort()
    return primeList

#testFun(primeFactors)
speedTestFun(primeFactors)
